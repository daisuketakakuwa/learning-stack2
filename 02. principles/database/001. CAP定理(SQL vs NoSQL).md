# SQL
ãƒ»SQL ï¼ RDB ï¼B+tree<br>
ãƒ»Oracle/MySQL/PostgreSQLã®INDEXã¯B+treeã‚’æ¡ç”¨ã€‚<br>
ãƒ»B+treeãŒå¾—æ„ã¨ã™ã‚‹æ¤œç´¢ã‚’å®Ÿç¾ã—ãŸã„å ´åˆ or ACIDã‚’å®Ÿç¾ã—ãŸã„å ´åˆã¯ã€RDB(SQL)ã‚’ä½¿ãˆã°OKğŸ‘

ç‰¹å¾´<br>
ãƒ»ãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’ä¸€æ„ã«ç‰¹å®šã§ãã‚‹PK<br>
ãƒ»ãƒ†ãƒ¼ãƒ–ãƒ«é–“ã‚’JOINã—ã¦å–å¾—<br>
ãƒ»ACID

## ACID
Relational database is ACID compliant.

### Atomicity
ãƒ»Atomï¼åŸå­ã€‚Splitã§ããªã„ã€‚<br>
ãƒ»transactions is ALL or NOTHING. A transaction canâ€™t be splited.

### Consistency
ãƒ¬ã‚³ãƒ¼ãƒ‰æ¶ˆã™ â–¶ï¸ ãã‚Œã‚’å¤–éƒ¨ã‚­ãƒ¼ã¨ã—ã¦å‚ç…§ã—ã¦ã„ã‚‹ãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’æ¶ˆã™ãªã‚Šã—ã¦ã€ä¸€è²«æ€§ã‚’ä¿ã¤ã€‚

### Isolation
- When multiple transactions runs concurrently, want them NOT to have side effects for each other.
- IsolationãŒä¿ãŸã‚Œãªã‹ã£ãŸã‚‰ã€Dirty Readãƒ»Phantom Readãƒ»Repeatable Readç™ºç”Ÿ

### Durability
Thatâ€™s why we use disks where persistent<br>
â—‹ Persistent<br>
â–³ Slower than memory


# Not Only SQL
ãƒ»not have relations<br>
ãƒ»canâ€™t join <br>
ãƒ»CAPï¼ˆACIDã‚’æº€ãŸã™å ´åˆã‚‚ã‚ã‚‹ï¼‰
```
â‘  Key-value store
â‘¡ Document store
â‘¢ Wide-column DB
â‘£ Graph-based DB
```

## â‘  Key-value store
ãƒ»no relation, just key-value<br>
ãƒ»id must be primary key<br>
â—‹ Faster because of **using RAM** not disks<br>
ğŸ‘‰Use-caseã¯ã€PrimaryDB(SQL)ã¨ä¸€ç·’ã«ã‚­ãƒ£ãƒƒã‚·ãƒ¥ç½®ãå ´ã—ã¨ã¦NoSQL

### Popular key-value store
ãƒ»Redis<br>
ãƒ»Memcached

## â‘¡ Document store
a kind of step-up from key-value stores

**Document = JSON object**<br>
ãƒ»multiple keys<br>
ãƒ»nested<br>
ãƒ»value can be object and array<br>
ãƒ»**no need to define schema** like tbl definitions

### Popular Document Store
ãƒ»AWS DynamoDB<br>
ãƒ»MongoDB

â€»â†“ãŸã ã®æ¤œç´¢ã‚¨ãƒ³ã‚¸ãƒ³ã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã§ã¯ãªã„ã€‚<br>
ãƒ»ElasticSearch<br>
ãƒ»OpenSearch

### RDBã§ã¯ãªãã€DocumentStoreã‚’ä½¿ã†ç†ç”±ã¯ï¼Ÿ
ãƒ»ACIDã§ã¯ãªã„ -> ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹å‘ä¸Šï¼ŸShardingï¼ŸCAPå®šç†<br>
ãƒ»ã‚¹ã‚­ãƒ¼ãƒå®šç¾©ã‚‰ã¸ã‚“


### DocumentDBã€æ·±å €ã‚Š
ãƒ»æŸ”è»Ÿã«ã‚¯ã‚¨ãƒª/æ¤œç´¢ ã™ã‚‹ãŸã‚ã®ãƒ‡ãƒ¼ã‚¿ã‚¹ãƒˆã‚¢<br>
ãƒ»ï¼‘ã¤ã®JSONã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ ï¼ Document<br>
ãƒ»ãã‚Œãã‚Œã®Documentã¯ç•°ãªã‚‹å±æ€§ã‚’ã‚‚ã£ã¦ã¦ã„ã„=**ã‚¹ã‚­ãƒ¼ãƒã®å®šç¾©ä¸è¦**

### Use case
ã‚«ã‚¿ãƒ­ã‚°<br>
ãƒ»å•†å“ã¨ã„ã†ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ãŒã‚ã‚‹å ´åˆã€**å„å•†å“ã”ã¨ã«ã—ã‹ã‚‚ãŸãªã„å¤§é‡ã®å±æ€§**ã‚ã‚‹ã€‚<br>
ãƒ»RDBã ã¨å…¨ã¦ã‚¹ã‚­ãƒ¼ãƒå®šç¾©ã«èµ·ã“ã™å¿…è¦ãŒã‚ã‚‹ãŒã€DocumentDBã¯ä¸è¦ã€‚

## â‘¢ Wide-column DB
ãƒ»Cassandra<br>
ãƒ»Google big table

## â‘£ Graph-based DB
This is all relations actuallyâ€¦<br>
â˜…SNSã§â€èª°ã‚’ãƒ•ã‚©ãƒ­ãƒ¼ã—ã¦ã‚‹ã®ã‹â€ã‚’RDBã§ç®¡ç†ã™ã‚‹ã®ã¯å¤§å¤‰â€¦<br>
This is NoSQL database by somehow keeps the feature of relations part.

# NoSQL uses Sharding (not Replication) ... means "Eventually Consistent"
Many many read and writes to database.... what do we do?

**o1. Vertical Scaling**

ã€€â†“ not enough by vertical scaling

**o2. Horizontal Scaling with "Replication"**

ã€€â†“ not enough by replication because of MASSIVE data<br>
ã€€when searching the amount of data **in a single machine** takes many time

**o3. Sharding**<br>
ãƒ»We've taken our **individual** database and **broken it into smaller pieces aka "shards"**.<br>
ãƒ»When a user reads and writes, they will go to individual shards.

<img width="500px" src="https://storage.googleapis.com/zenn-user-upload/7c9ed4b67d6d-20230427.png" />

Benefits of shards<br>
âœ…Balance more traffics.<br>
âœ…Queries go faster because each database has the half data.

## How to distribute data into shards?
Take one item "**Shard key**" which is used to decide how to split the data up.
### 1. Range-based shard key
For ex, we have gender column which contains MALE or FEMALE.<br>
If we take gender column as Range-based shard key, <br>
ã€€Shard 1 have All MAKE data.<br>
ã€€Shard 2 have All FEMALE data.
 
 ### 2. Hash-based shard key
 This is a use-case for **consistent hashing**.
 
 ## Why difficult to use Sharding? -> keep consistent relation /:
 When we have two related tables, we have to keep consistent both of them.

## SQL databases(MySQL/PostgreSQL) not have sharding by default...
It make sense because SQL database is naturally not meant to be distributed in sharding way. <br>
When doing sharding, **we lose the consistency the we get from ACID**.

## NoSQL database have sharding by default!!!
ãƒ»**NoSQL databases are natually meant to be sharded.**<br>
ãƒ»Our data is **non-relational**.<br>
ãƒ»The data doesn't even have to be consistent from the notes.<br>
ãƒ»They will be **eventually consistent.**


# Cap Theorem/CAPå®šç†

C(Consistency)<br>
ãƒ»Primaryã‚‚Replicaã‚‚**ã„ã¤ã‚¢ã‚¯ã‚»ã‚¹ã—ã¦ã‚‚å¸¸ã«åŒã˜ãƒ‡ãƒ¼ã‚¿ãŒå‚ç…§ã§ãã‚‹(ä¸€è²«ã—ã¦ã„ã‚‹)**ã“ã¨ã€‚<br>
â€»RDBã®ACIDã®Cã¯ã€Œå¤–éƒ¨åˆ¶ç´„ã«ã‚ˆã‚‹ä¸€è²«æ€§ã€ã€‚NoSQLã®CAPã®Cã¯ã€Œ**Nodeé–“ã®ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§**ã€

A(Availability)<br>
ãƒ»Node1ãŒãƒ€ã‚¦ãƒ³ã—ã¦ã‚‚ Node2ã«ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½ãªçŠ¶æ…‹ã€‚<br>

P(**Partition/NWåˆ†æ–­** Tolerant)<br>
ãƒ»Node1ãŒã‚ã‚‹NW1ãŒåˆ†æ–­ã•ã‚ŒãŸçŠ¶æ…‹(ã‚¢ã‚¯ã‚»ã‚¹ã§ããªããªã£ãŸçŠ¶æ…‹)ã®ã¨ãã«ã€<br>
ã€€Node2ãŒã‚ã‚‹NW2ã«ã¯ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹ã‹ã‚‰ **NWåˆ†æ–­(Partition)ã«è€æ€§ãŒã‚ã‚‹**ã“ã¨ã€‚<br>

âœ…RDBã¯Primary-Replicaé–“ã§å¸¸ã«ãƒ‡ãƒ¼ã‚¿ã‚’åŒã˜çŠ¶æ…‹ã«ã™ã‚‹ãŸã‚ã«ã€**åŒã˜NWã«Primaryã¨Replicaã‚’é…ç½®ã™ã‚‹ã®ãŒä¸€èˆ¬çš„ã€ã€‡CA âœ•Pã€‘**

<img width="500px" src="https://github.com/daisuketakakuwa/learning-stack/assets/66095465/ba780787-6f2e-4720-8b28-c0adbf16b946" />

âœ…NoSQLã¯**Partition(NWåˆ†æ–­)ã¸ã®è€æ€§ã‚’å¸¸ã«ç¢ºä¿ã—ãŸã„**ã®ã§Pã¯å¸¸ã«ç¢ºä¿ã—ãŸã„ã€‚<br>
ã€€ â†’ APãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ or CPãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ ã®ã©ã¡ã‚‰ã‹ã‚’é¸ã¶å¿…è¦ãŒã‚ã‚‹ã€‚

<img width="500px" src="https://github.com/daisuketakakuwa/learning-stack/assets/66095465/2158c6ad-08b3-491f-8323-df7c4a1f6787" />
<br>
<img width="500px" src="https://github.com/daisuketakakuwa/learning-stack/assets/66095465/c7adef8b-154f-446e-b664-b6874d926aa6" />

# PACELC
PAC = CAP
Given P(partition),
choose A or C,

Else (åŒã˜NW/Partitionã«ã‚ã‚‹å ´åˆ)
â€»NW/Partition toleranceã‚’æ°—ã«ã—ãªã„ç’°å¢ƒã§
favor Latency or Consistency ã©ã£ã¡ã‚’ã¨ã‚‹ï¼Ÿ

Want lower latency
â–¶ï¸Read replica asap
Want consistency
â–¶ï¸Wait for replication a few second

åŒã˜NWå†…ã§ã‚‚Followerã¸ã®ãƒ‡ãƒ¼ã‚¿åŒæœŸã¯ã‹ã‹ã‚‹


