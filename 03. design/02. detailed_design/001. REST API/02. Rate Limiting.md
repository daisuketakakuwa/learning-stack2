# Basic Idea
We need rate limiting because of **security reason.**

Let's say we can upload 20 videos per day and have two instances having uploading API.

âœ…We should implment a rate limiter as kind of shared service.

<img src="https://storage.googleapis.com/zenn-user-upload/d2839a2c31d7-20230601.png" width="500px" />

When the rate limit has been reached, tell users that they are **throttled.**<br>
ãƒ»ã‚¹ãƒ­ãƒƒãƒˆãƒ«ã¯ã€ä¸€å®šã®é–¾å€¤ã‚’è¶…ãˆãŸå ´åˆã«é€šä¿¡é‡ã‚’æ„å›³çš„ã«æŠ‘åˆ¶ã™ã‚‹åˆ¶å¾¡ã®ã“ã¨ã€‚<br>
ãƒ»ãªã®ã§"throttle"ã¨ã„ã†å‹•è©ã¯ã€Œ**é–¾å€¤è¶…ãˆãŸã®ã§é€šä¿¡é‡ä¸€æ—¦æŠ‘ãˆã¾ã™**ã€ã¨ã„ã†æ„å‘³ã€‚

<img src="https://storage.googleapis.com/zenn-user-upload/b11b252dfc38-20230601.png" width="500px" />

# Non-functional requirement
## Latency
âœ…We want to pretend like the rate limiter doesn't even exist so that latency is super low. <br>
ã€€ **Rate limiterã‚’ä»²ä»‹ã™ã‚‹ã“ã¨ã§Latencyã«å½±éŸ¿ã¯ä¸ãˆãŸããªã„ã€‚Rate limiterã¯å­˜åœ¨ã—ãªã„ãã‚‰ã„ã®æ‰±ã„ã«ã—ãŸã„ã€‚**

Quick reads and writes leads to less latency... so<br>
ğŸ”´Preventing reading from disk(rules) can make it faster by placing cache.<br>
ã€€â†’ Rules won't be updated frequently.

<img src="https://storage.googleapis.com/zenn-user-upload/10b9245c7216-20230602.png" width="500px" />

## Availability
**Fail-Open**
Something in our system goes down, our entire system including the apis should **function as if the rate limiter never existed.**

**Fail-Closed**
Something in our system goes down, our entire system basically goes down and tell a user internal server error 500.

# High Level Design
âœ…Rate Limit server acts like a reverse proxy.
1. Store and read rules in persistent storage.
2. Store and read counts in in-memory key-value store.
3. Navitate requests to endpoints if the rate limit is not over.

â€»APIã”ã¨ã«ç•°ãªã‚‹Ruleã‚’é©ç”¨ã—ãŸã„ -> Storageã«Ruleã‚’å®šç¾©ï¼†ä½¿ã†ã¨ãã«å–å¾—ã™ã‚‹ã€‚<br>
â€»Ruleï¼ˆruleId: xxxx, targetApi: xxxxx, timeUnit: ç§’/åˆ†, alg: xxxxx, maxRequests: 1000)

<img src="https://storage.googleapis.com/zenn-user-upload/852b1fb269ac-20230602.png" width="500px" />

# Detailed Design
## Algorithm
|Algorithm|Description|
|----|----|
|Fixed Window|â–³less accurate, â—‹less cost-intensive.|
|Sliding Window|â—‹more accurate, â–³more cost-intensive.|
|Token Bucket||
|Sliding Window Counter|a balance between fixed window and sliding window|
### Fixed Window
ãƒ»Disregard the previous fixed window.<br>
ãƒ»1ç§’é–“ã®ä¸­ã§ã‚«ã‚¦ãƒ³ãƒˆã ã‘ã—ã¦ã‚Œã°ã„ã„ã€‚æ¬¡å‘¨æœŸã«å…¥ã£ãŸã‚‰ã‚«ã‚¦ãƒ³ãƒˆã‚’ãƒªã‚»ãƒƒãƒˆ<br>
ã€€= å„ãƒªã‚¯ã‚¨ã‚¹ãƒˆã®Timestampã‚’è¨˜éŒ²ã—ã¦ãŠãå¿…è¦ã¯ãªã„ã€‚

1ç§’é–“ã®ä¸­ã§100ãƒªã‚¯ã‚¨ã‚¹ãƒˆã¾ã§ã€ã¨ã„ã†ç™ºæƒ³ã€‚<br>
ãªã®ã§<br>
ãƒ»0.9 - 1.0ç§’ ã®é–“ã«100ãƒªã‚¯ã‚¨ã‚¹ãƒˆ<br>
ãƒ»1.0 - 1.1ç§’ ã®é–“ã«100ãƒªã‚¯ã‚¨ã‚¹ãƒˆ<br>
ã¤ã¾ã‚Š**0.2ç§’é–“ã«200ãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒã‚ã£ã¦ã‚‚ã€å„1ç§’é–“ã§100ãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒåã¾ã£ã¦ã‚‹**ã®ã§ã€OKã¨ãªã‚‹ã€‚

<img src="https://storage.googleapis.com/zenn-user-upload/52b6feea72d0-20230602.png" width="500px" />

â†“ What would be a better algorithm that would be more accurate?

### Sliding Window
ãƒ»Check the requests unti the last 1 minitues = shift window

<img src="https://storage.googleapis.com/zenn-user-upload/23581372bd1e-20230602.png" width="500px" />

â–³ We have to store the exact timestamp for each request.

ğŸ”´Can be implmented by **Redis Sorted-Set**
ã€€â†’ ã‚½ãƒ¼ãƒˆåŸºæº–ã¨ãªã‚‹ã‚¹ã‚³ã‚¢ã«Timestampã‚’åˆ©ç”¨ã™ã‚Œã°OKã€‚

https://redis.io/docs/data-types/sorted-sets/

### Token Bucket

### Sliding Window Counter

# scaling in-memory store horizontally
We have to navigate requests to the same in-memory store every single time... how can we accomplish? -> **Consistent Hashing**
