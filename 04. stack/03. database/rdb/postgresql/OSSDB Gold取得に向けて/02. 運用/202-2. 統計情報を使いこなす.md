## よく使う統計情報
- `pg_locks` → ロック情報
- `pg_stat_activity` → 各BEプロセスが実行しているクエリチェック
- `pg_stat_database` → 接続数やヒープアクセス状況などをDB単位で確認
- `pg_stat_all_tables` → 各テーブルにおけるSeqScan数、IndeScan数、DeadTuple数を確認
- `pg_stat_statements` → ✅拡張機能。実行時間長い/呼ばれすぎなクエリを確認⇒チューニングする。

## pg_class = オブジェクトの物理情報
- オブジェクト is
  - テーブル(relation)
  - インデックス
  - PK,FK制約 

```sql
SELECT
  oid,
  relname,
  relfilenode,
  relpages,
  reltuples
FROM
  pg_class
WHERE
  relname NOT LIKE '%pg_%';
```

## pg_locks = ロック確保/ロック待ち状況
- テーブル単位/行単位で発生しているロックを確認できる。
- `granted`： true → ロック獲得済、false → `ロック待ち`

<img width="700px" src="https://github.com/user-attachments/assets/7cddf666-0c27-4f2a-bae4-25e5f5ad57d8" />


### locksのテーブル情報は「oid(オブジェクトID)」なので、論理名をpg_classからとってくる

- `pg_locks > relation`にはオブジェクトIDが入っている（論理名ではない）

<img width="700px" src="https://github.com/user-attachments/assets/7a470784-30dc-4954-ad75-79209ba37588" />

### どのクエリが待機(ロック待ち)なのか、pg_stat_activityからとってくる
- locks も activityも「BEプロセス」に紐づく情報なので、`pid`で紐づける。

<img width="700px" src="https://github.com/user-attachments/assets/59d607b2-cf9a-42e1-840e-1ed931985685" />

## pg_stat_statements
- スロークエリ：**単発**で処理実行時間が長かったSQLログ（`log_min_duration_statement`で設定）
- `pg_stat_statements`：**すべての実行クエリ**をもとに計算した統計情報
<img width="600px" src="https://github.com/user-attachments/assets/5f779237-2920-4eef-a47d-9e6ca38c5288" />

### スロークエリと`pg_stat_statements`でのクエリ監視/運用方法
👉スロークエリログは「単発の異常値」⇒ 個別チューニング<br>
👉`pg_stat_statements` は「全体の傾向・累積負荷」⇒ 優先度順に対応。管理。 <br>
✅両方を組み合わせると 短期的ボトルネックと長期的負荷の両方 を監視できる
